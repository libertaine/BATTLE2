diff --git a/engine/src/battle_engine/cli.py b/engine/src/battle_engine/cli.py
index 0000000..1111111 100644
--- a/engine/src/battle_engine/cli.py
+++ b/engine/src/battle_engine/cli.py
@@ -1,12 +1,115 @@
 from __future__ import annotations
 import argparse
 import json
 import os
+import sys
+from pathlib import Path
+from typing import Any, Dict, Iterable
+
+from .agents import (
+    AgentSpec,
+    discover_agents,
+    resolve_agent,
+)
 
-# existing imports...
+# existing imports...
 
-def build_parser() -> argparse.ArgumentParser:
+def _battle_root() -> Path:
+    """
+    Determine <BATTLE_ROOT>.
+    Priority:
+      1) env:BATTLE_ROOT
+      2) repo layout relative to this file: <root>/engine/src/battle_engine/cli.py
+    """
+    env = os.environ.get("BATTLE_ROOT")
+    if env:
+        return Path(env).expanduser().resolve()
+    here = Path(__file__).resolve()
+    # .../engine/src/battle_engine/cli.py  => parents[4] is <root>
+    # [0]=cli.py, [1]=battle_engine, [2]=src, [3]=engine, [4]=<root>
+    try:
+        return here.parents[4]
+    except IndexError:
+        # Fallback: walk up to find 'engine' sibling 'agents'
+        p = here
+        for _ in range(8):
+            if (p / "engine").is_dir() and (p / "agents").is_dir():
+                return p
+            p = p.parent
+        return here.parent.parent  # last resort
+
+
+def _parse_env_json(varname: str) -> Dict[str, Any]:
+    """
+    Read JSON object from environment variable. Return {} on empty/missing.
+    Produce a helpful error on malformed input.
+    """
+    raw = os.environ.get(varname, "").strip()
+    if not raw:
+        return {}
+    try:
+        obj = json.loads(raw)
+    except Exception as e:
+        raise SystemExit(
+            f"Malformed JSON in ${varname}: {e}\nValue: {raw[:200]}..."
+        )
+    if not isinstance(obj, dict):
+        raise SystemExit(f"${varname} must be a JSON object (got {type(obj).__name__}).")
+    return obj
+
+
+def _merge_params(defaults: Dict[str, Any], overrides: Dict[str, Any]) -> Dict[str, Any]:
+    """
+    Shallow merge: overrides win on conflicting keys.
+    """
+    if not defaults:
+        return dict(overrides or {})
+    if not overrides:
+        return dict(defaults or {})
+    merged = dict(defaults)
+    merged.update(overrides)
+    return merged
+
+
+def _keys_preview(d: Dict[str, Any]) -> str:
+    return "{" + ", ".join(sorted(map(str, d.keys()))) + "}"
+
+
+def build_parser() -> argparse.ArgumentParser:
     p = argparse.ArgumentParser(prog="BATTLE", description="Battle engine CLI")
-    # existing flags...
-    p.add_argument("--a-type", choices=["runner", "writer", "bomber", "flooder", "spiral", "seeker"], default="runner")
-    p.add_argument("--b-type", choices=["runner", "writer", "bomber", "flooder", "spiral", "seeker"], default="runner")
-    p.add_argument("--c-type", choices=["runner", "writer", "bomber", "flooder", "spiral", "seeker"])
+    # existing flags...
+    # Accept arbitrary agent names: remove choices, allow any non-empty string
+    p.add_argument("--a-type", type=str, default="runner", help="Agent name for side A (folder under <root>/agents/)")
+    p.add_argument("--b-type", type=str, default="runner", help="Agent name for side B (folder under <root>/agents/)")
+    p.add_argument("--c-type", type=str, default=None, help="Optional agent name for side C (folder under <root>/agents/)")
+
+    # If blobs are supported/optional, expose explicit overrides.
+    p.add_argument("--a-blob", type=str, default=None, help="Explicit model blob path for agent A")
+    p.add_argument("--b-blob", type=str, default=None, help="Explicit model blob path for agent B")
+    p.add_argument("--c-blob", type=str, default=None, help="Explicit model blob path for agent C")
+
+    # Nice-to-have: list discovered agents and exit
+    p.add_argument("--list-agents", action="store_true", help="List discovered agents and exit")
 
     # keep existing options intact (arena, ticks, win-mode, weights, etc.)
     # ...
     return p
 
 
 def main(argv: Iterable[str] | None = None) -> int:
     parser = build_parser()
     args = parser.parse_args(argv)
 
+    root = _battle_root()
+
+    # Listing mode
+    if getattr(args, "list_agents", False):
+        specs = discover_agents(root)
+        if not specs:
+            print(f"No agents found under {root / 'agents'}")
+            return 0
+        print("Discovered agents:")
+        for name, spec in sorted(specs.items()):
+            disp = f"{spec.display}" if spec.display and spec.display != name else ""
+            blob = spec.blob.name if spec.blob else "â€”"
+            print(f"  - {name:20} {disp:20} blob={blob}")
+        return 0
+
+    # Resolve A/B(/C) agents
+    def _resolve_side(side: str, name: str | None, blob_flag: str | None, env_var: str) -> tuple[AgentSpec, Dict[str, Any], Path | None]:
+        if not name:
+            raise SystemExit(f"Agent for side '{side}' is required.")
+        spec = resolve_agent(root, name)
+        env_params = _parse_env_json(env_var)
+        merged = _merge_params(spec.defaults or {}, env_params)
+        # blob precedence: CLI flag > env['blob_path'] > spec.blob
+        blob_path: Path | None = None
+        if blob_flag:
+            blob_path = Path(blob_flag).expanduser().resolve()
+        elif isinstance(env_params.get("blob_path"), str):
+            blob_val = env_params["blob_path"]
+            blob_path = Path(blob_val).expanduser()
+            if not blob_path.is_absolute():
+                blob_path = (root / blob_path).resolve()
+            else:
+                blob_path = blob_path.resolve()
+        else:
+            blob_path = spec.blob
+
+        # Validation: if there is NO agent.py and NO blob, we cannot run model-based agents
+        if (spec.dir / "agent.py").exists():
+            pass  # code-based agent; blob optional
+        else:
+            if blob_path is None or not blob_path.exists():
+                raise SystemExit(
+                    f"No blob specified for agent '{name}'. "
+                    f"Provide model.blob in agents/{name}/ or pass via env JSON key 'blob_path' "
+                    f"(in ${env_var}) or CLI --{side.lower()}-blob"
+                )
+        return spec, merged, blob_path
+
+    a_spec, a_params, a_blob = _resolve_side("A", args.a_type, args.a_blob, "BATTLE_AGENT_A_PARAMS_JSON")
+    b_spec, b_params, b_blob = _resolve_side("B", args.b_type, args.b_blob, "BATTLE_AGENT_B_PARAMS_JSON")
+    c_tuple = None
+    if args.c_type:
+        c_tuple = _resolve_side("C", args.c_type, args.c_blob, "BATTLE_AGENT_C_PARAMS_JSON")
+
+    # Concise startup summary (keys only)
+    print("Agents:")
+    print(f"  A: {a_spec.name}  blob={str(a_blob) if a_blob else 'none'}  params={_keys_preview(a_params)}")
+    print(f"  B: {b_spec.name}  blob={str(b_blob) if b_blob else 'none'}  params={_keys_preview(b_params)}")
+    if c_tuple:
+        c_spec, c_params, c_blob = c_tuple
+        print(f"  C: {c_spec.name}  blob={str(c_blob) if c_blob else 'none'}  params={_keys_preview(c_params)}")
+
     # existing run logic remains intact...
-    # return 0
+    return 0
 
 
 if __name__ == "__main__":
     raise SystemExit(main())
diff --git a/engine/src/battle_engine/agents.py b/engine/src/battle_engine/agents.py
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/engine/src/battle_engine/agents.py
@@ -0,0 +1,137 @@
+from __future__ import annotations
+
+import json
+from dataclasses import dataclass
+from pathlib import Path
+from typing import Any, Dict
+
+__all__ = [
+    "AgentSpec",
+    "discover_agents",
+    "resolve_agent",
+]
+
+
+@dataclass
+class AgentSpec:
+    name: str
+    display: str
+    dir: Path
+    blob: Path | None
+    defaults: Dict[str, Any]
+
+
+def _agents_root(root: Path) -> Path:
+    return (root / "agents").resolve()
+
+
+def _read_json_like(path: Path) -> Dict[str, Any]:
+    """
+    Parse agent.yaml as JSON (no YAML dependency).
+    Allows:
+      - // and # comments (stripped)
+      - simple trailing comma cleanup
+    """
+    text = path.read_text(encoding="utf-8")
+    lines = []
+    for line in text.splitlines():
+        s = line.split("//", 1)[0]
+        s = s.split("#", 1)[0]
+        lines.append(s)
+    cleansed = "\n".join(lines)
+    cleansed = cleansed.replace(",}", "}").replace(", }", " }").replace(",]", "]").replace(", ]", " ]")
+    data = json.loads(cleansed) if cleansed.strip() else {}
+    if not isinstance(data, dict):
+        raise ValueError(f"{path} must contain a JSON object.")
+    return data
+
+
+def _spec_from_dir(agent_dir: Path) -> AgentSpec | None:
+    if not agent_dir.is_dir():
+        return None
+    name = agent_dir.name
+    yaml_path = agent_dir / "agent.yaml"
+    py_path = agent_dir / "agent.py"
+    blob_path = agent_dir / "model.blob"
+
+    display = name
+    defaults: Dict[str, Any] = {}
+
+    if yaml_path.exists():
+        try:
+            meta = _read_json_like(yaml_path)
+        except Exception as e:
+            raise SystemExit(f"Failed parsing {yaml_path}: {e}")
+        display = str(meta.get("display") or meta.get("name") or name)
+        if "defaults" in meta:
+            if isinstance(meta["defaults"], dict):
+                defaults = dict(meta["defaults"])
+            else:
+                raise SystemExit(f"'defaults' in {yaml_path} must be an object.")
+    else:
+        if not py_path.exists():
+            # not a valid agent folder by our rules
+            return None
+        # agent.py exists; infer minimal metadata
+        display = name
+        defaults = {}
+
+    blob = blob_path if blob_path.exists() else None
+    return AgentSpec(name=name, display=display, dir=agent_dir, blob=blob, defaults=defaults)
+
+
+def discover_agents(root: Path) -> Dict[str, AgentSpec]:
+    base = _agents_root(root)
+    if not base.exists():
+        return {}
+    specs: Dict[str, AgentSpec] = {}
+    for child in sorted(base.iterdir()):
+        if not child.is_dir():
+            continue
+        spec = _spec_from_dir(child)
+        if spec:
+            specs[spec.name] = spec
+    return specs
+
+
+def resolve_agent(root: Path, name: str) -> AgentSpec:
+    if not name or not name.strip():
+        raise SystemExit("Agent name cannot be empty.")
+    agent_dir = _agents_root(root) / name
+    spec = _spec_from_dir(agent_dir)
+    if spec is None:
+        raise SystemExit(
+            f"Unknown agent '{name}'. Expected a folder {agent_dir} with agent.yaml (JSON) or agent.py"
+        )
+    return spec

